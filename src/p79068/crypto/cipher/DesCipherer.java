package p79068.crypto.cipher;

import p79068.Assert;
import p79068.crypto.Zeroizer;


final class DesCipherer extends AbstractCipherer {
	
	private long[] keySchedule;
	private long[] keyScheduleReverse;
	
	
	
	DesCipherer(Des cipher, byte[] key) {
		super(cipher, key);
		
		long tempKey = 0;
		for (byte b : key)
			tempKey = (tempKey << 8) | (b & 0xFF);
		
		// Add padding bits
		if (key.length == 7) {
			for (int i = 0; i < 8; i++) {
				long mask = (1L << (i * 8)) - 1;
				tempKey = ((tempKey & ~mask) << 1) | (tempKey & mask);
			}
		}
		
		keySchedule = new long[KEY_SCHEDULE_SHIFTS.length];
		keyScheduleReverse = new long[KEY_SCHEDULE_SHIFTS.length];
		long left  = permuteBits(tempKey, PERMUTED_CHOICE_1_LEFT );
		long right = permuteBits(tempKey, PERMUTED_CHOICE_1_RIGHT);
		for (int i = 0; i < KEY_SCHEDULE_SHIFTS.length; i++) {
			int s = KEY_SCHEDULE_SHIFTS[i];
			left  = ((left  << s) | (left  >>> (28 - s))) & HALF_KEY_MASK;
			right = ((right << s) | (right >>> (28 - s))) & HALF_KEY_MASK;
			keySchedule[i] = permuteBits((left << 28) | right, PERMUTED_CHOICE_2);
			keyScheduleReverse[keySchedule.length - 1 - i] = keySchedule[i];
		}
	}
	
	
	
	@Override
	public void encrypt(byte[] b, int off, int len) {
		if (cipher == null)
			throw new IllegalStateException("Already zeroized");
		Assert.assertRangeInBounds(b.length, off, len);
		if (len % 8 != 0)
			throw new IllegalArgumentException("Invalid block length");
		crypt(b, off, len, keySchedule);
	}
	
	
	@Override
	public void decrypt(byte[] b, int off, int len) {
		if (cipher == null)
			throw new IllegalStateException("Already zeroized");
		Assert.assertRangeInBounds(b.length, off, len);
		if (len % 8 != 0)
			throw new IllegalArgumentException("Invalid block length");
		crypt(b, off, len, keyScheduleReverse);
	}
	
	
	private void crypt(byte[] b, int off, int len, long[] keySch) {
		for (int i = off, end = off + len; i < end; i += 8) {
			// Pack and initial permutation
			long longBlock = ((b[i + 0] & 0xFFL) << 56)
			               | ((b[i + 1] & 0xFFL) << 48)
			               | ((b[i + 2] & 0xFFL) << 40)
			               | ((b[i + 3] & 0xFFL) << 32)
			               | ((b[i + 4] & 0xFFL) << 24)
			               | ((b[i + 5] & 0xFFL) << 16)
			               | ((b[i + 6] & 0xFFL) <<  8)
			               | ((b[i + 7] & 0xFFL) <<  0);
			longBlock = permuteBits(longBlock, INITIAL_PERMUTATION);
			
			// Do 16 rounds
			int left = (int)(longBlock >>> 32);
			int right = (int)longBlock;
			for (long subkey : keySch) {
				int oldRight = right;
				long temp = permuteBits(right, FEISTEL_EXPANSION) ^ subkey;
				right = left ^ (int)permuteBits(substitute(temp), FEISTEL_PERMUTATION);
				left = oldRight;
			}
			
			// Final permutation and unpack
			longBlock = permuteBits(((long)right << 32) | (left & 0xFFFFFFFFL), FINAL_PERMUTATION);
			b[i + 0] = (byte)(longBlock >>> 56);
			b[i + 1] = (byte)(longBlock >>> 48);
			b[i + 2] = (byte)(longBlock >>> 40);
			b[i + 3] = (byte)(longBlock >>> 32);
			b[i + 4] = (byte)(longBlock >>> 24);
			b[i + 5] = (byte)(longBlock >>> 16);
			b[i + 6] = (byte)(longBlock >>>  8);
			b[i + 7] = (byte)(longBlock >>>  0);
		}
	}
	
	
	@Override
	public DesCipherer clone() {
		DesCipherer result = (DesCipherer)super.clone();
		result.keySchedule = result.keySchedule.clone();
		result.keyScheduleReverse = result.keyScheduleReverse.clone();
		return result;
	}
	
	
	@Override
	public void zeroize() {
		if (cipher == null)
			return;
		keySchedule = Zeroizer.clear(keySchedule);
		keyScheduleReverse = Zeroizer.clear(keyScheduleReverse);
		super.zeroize();
	}
	
	
	// Utility functions
	
	private static int substitute(long data) {
		int result = 0;
		for (int i = 0; i < 8; i++)
			result |= SBOXES[i][(int)(data >>> (i * 6)) & 0x3F] << (i * 4);
		return result;
	}
	
	
	private static long permuteBits(long data, int[] perm) {
		long result = 0;
		for (int i : perm)
			result = (result << 1) | ((data >>> i) & 1);
		return result;
	}
	
	
	// Tables of constants
	
	private static int[][] SBOXES = {
		{0xD, 0x1, 0x2, 0xF, 0x8, 0xD, 0x4, 0x8, 0x6, 0xA, 0xF, 0x3, 0xB, 0x7, 0x1, 0x4, 0xA, 0xC, 0x9, 0x5, 0x3, 0x6, 0xE, 0xB, 0x5, 0x0, 0x0, 0xE, 0xC, 0x9, 0x7, 0x2, 0x7, 0x2, 0xB, 0x1, 0x4, 0xE, 0x1, 0x7, 0x9, 0x4, 0xC, 0xA, 0xE, 0x8, 0x2, 0xD, 0x0, 0xF, 0x6, 0xC, 0xA, 0x9, 0xD, 0x0, 0xF, 0x3, 0x3, 0x5, 0x5, 0x6, 0x8, 0xB},
		{0x4, 0xD, 0xB, 0x0, 0x2, 0xB, 0xE, 0x7, 0xF, 0x4, 0x0, 0x9, 0x8, 0x1, 0xD, 0xA, 0x3, 0xE, 0xC, 0x3, 0x9, 0x5, 0x7, 0xC, 0x5, 0x2, 0xA, 0xF, 0x6, 0x8, 0x1, 0x6, 0x1, 0x6, 0x4, 0xB, 0xB, 0xD, 0xD, 0x8, 0xC, 0x1, 0x3, 0x4, 0x7, 0xA, 0xE, 0x7, 0xA, 0x9, 0xF, 0x5, 0x6, 0x0, 0x8, 0xF, 0x0, 0xE, 0x5, 0x2, 0x9, 0x3, 0x2, 0xC},
		{0xC, 0xA, 0x1, 0xF, 0xA, 0x4, 0xF, 0x2, 0x9, 0x7, 0x2, 0xC, 0x6, 0x9, 0x8, 0x5, 0x0, 0x6, 0xD, 0x1, 0x3, 0xD, 0x4, 0xE, 0xE, 0x0, 0x7, 0xB, 0x5, 0x3, 0xB, 0x8, 0x9, 0x4, 0xE, 0x3, 0xF, 0x2, 0x5, 0xC, 0x2, 0x9, 0x8, 0x5, 0xC, 0xF, 0x3, 0xA, 0x7, 0xB, 0x0, 0xE, 0x4, 0x1, 0xA, 0x7, 0x1, 0x6, 0xD, 0x0, 0xB, 0x8, 0x6, 0xD},
		{0x2, 0xE, 0xC, 0xB, 0x4, 0x2, 0x1, 0xC, 0x7, 0x4, 0xA, 0x7, 0xB, 0xD, 0x6, 0x1, 0x8, 0x5, 0x5, 0x0, 0x3, 0xF, 0xF, 0xA, 0xD, 0x3, 0x0, 0x9, 0xE, 0x8, 0x9, 0x6, 0x4, 0xB, 0x2, 0x8, 0x1, 0xC, 0xB, 0x7, 0xA, 0x1, 0xD, 0xE, 0x7, 0x2, 0x8, 0xD, 0xF, 0x6, 0x9, 0xF, 0xC, 0x0, 0x5, 0x9, 0x6, 0xA, 0x3, 0x4, 0x0, 0x5, 0xE, 0x3},
		{0x7, 0xD, 0xD, 0x8, 0xE, 0xB, 0x3, 0x5, 0x0, 0x6, 0x6, 0xF, 0x9, 0x0, 0xA, 0x3, 0x1, 0x4, 0x2, 0x7, 0x8, 0x2, 0x5, 0xC, 0xB, 0x1, 0xC, 0xA, 0x4, 0xE, 0xF, 0x9, 0xA, 0x3, 0x6, 0xF, 0x9, 0x0, 0x0, 0x6, 0xC, 0xA, 0xB, 0x1, 0x7, 0xD, 0xD, 0x8, 0xF, 0x9, 0x1, 0x4, 0x3, 0x5, 0xE, 0xB, 0x5, 0xC, 0x2, 0x7, 0x8, 0x2, 0x4, 0xE},
		{0xA, 0xD, 0x0, 0x7, 0x9, 0x0, 0xE, 0x9, 0x6, 0x3, 0x3, 0x4, 0xF, 0x6, 0x5, 0xA, 0x1, 0x2, 0xD, 0x8, 0xC, 0x5, 0x7, 0xE, 0xB, 0xC, 0x4, 0xB, 0x2, 0xF, 0x8, 0x1, 0xD, 0x1, 0x6, 0xA, 0x4, 0xD, 0x9, 0x0, 0x8, 0x6, 0xF, 0x9, 0x3, 0x8, 0x0, 0x7, 0xB, 0x4, 0x1, 0xF, 0x2, 0xE, 0xC, 0x3, 0x5, 0xB, 0xA, 0x5, 0xE, 0x2, 0x7, 0xC},
		{0xF, 0x3, 0x1, 0xD, 0x8, 0x4, 0xE, 0x7, 0x6, 0xF, 0xB, 0x2, 0x3, 0x8, 0x4, 0xE, 0x9, 0xC, 0x7, 0x0, 0x2, 0x1, 0xD, 0xA, 0xC, 0x6, 0x0, 0x9, 0x5, 0xB, 0xA, 0x5, 0x0, 0xD, 0xE, 0x8, 0x7, 0xA, 0xB, 0x1, 0xA, 0x3, 0x4, 0xF, 0xD, 0x4, 0x1, 0x2, 0x5, 0xB, 0x8, 0x6, 0xC, 0x7, 0x6, 0xC, 0x9, 0x0, 0x3, 0x5, 0x2, 0xE, 0xF, 0x9},
		{0xE, 0x0, 0x4, 0xF, 0xD, 0x7, 0x1, 0x4, 0x2, 0xE, 0xF, 0x2, 0xB, 0xD, 0x8, 0x1, 0x3, 0xA, 0xA, 0x6, 0x6, 0xC, 0xC, 0xB, 0x5, 0x9, 0x9, 0x5, 0x0, 0x3, 0x7, 0x8, 0x4, 0xF, 0x1, 0xC, 0xE, 0x8, 0x8, 0x2, 0xD, 0x4, 0x6, 0x9, 0x2, 0x1, 0xB, 0x7, 0xF, 0x5, 0xC, 0xB, 0x9, 0x3, 0x7, 0xE, 0x3, 0xA, 0xA, 0x0, 0x5, 0x6, 0x0, 0xD},
	};
	
	private static int[] INITIAL_PERMUTATION = {6, 14, 22, 30, 38, 46, 54, 62, 4, 12, 20, 28, 36, 44, 52, 60, 2, 10, 18, 26, 34, 42, 50, 58, 0, 8, 16, 24, 32, 40, 48, 56, 7, 15, 23, 31, 39, 47, 55, 63, 5, 13, 21, 29, 37, 45, 53, 61, 3, 11, 19, 27, 35, 43, 51, 59, 1, 9, 17, 25, 33, 41, 49, 57};
	private static int[] FINAL_PERMUTATION = {24, 56, 16, 48, 8, 40, 0, 32, 25, 57, 17, 49, 9, 41, 1, 33, 26, 58, 18, 50, 10, 42, 2, 34, 27, 59, 19, 51, 11, 43, 3, 35, 28, 60, 20, 52, 12, 44, 4, 36, 29, 61, 21, 53, 13, 45, 5, 37, 30, 62, 22, 54, 14, 46, 6, 38, 31, 63, 23, 55, 15, 47, 7, 39};
	private static int[] FEISTEL_EXPANSION = {0, 31, 30, 29, 28, 27, 28, 27, 26, 25, 24, 23, 24, 23, 22, 21, 20, 19, 20, 19, 18, 17, 16, 15, 16, 15, 14, 13, 12, 11, 12, 11, 10, 9, 8, 7, 8, 7, 6, 5, 4, 3, 4, 3, 2, 1, 0, 31};
	private static int[] FEISTEL_PERMUTATION = {16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7};
	private static int[] PERMUTED_CHOICE_1_LEFT = {7, 15, 23, 31, 39, 47, 55, 63, 6, 14, 22, 30, 38, 46, 54, 62, 5, 13, 21, 29, 37, 45, 53, 61, 4, 12, 20, 28};
	private static int[] PERMUTED_CHOICE_1_RIGHT = {1, 9, 17, 25, 33, 41, 49, 57, 2, 10, 18, 26, 34, 42, 50, 58, 3, 11, 19, 27, 35, 43, 51, 59, 36, 44, 52, 60};
	private static int[] PERMUTED_CHOICE_2 = {42, 39, 45, 32, 55, 51, 53, 28, 41, 50, 35, 46, 33, 37, 44, 52, 30, 48, 40, 49, 29, 36, 43, 54, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24};
	
	private static int HALF_KEY_MASK = (1 << 28) - 1;
	
	private static int[] KEY_SCHEDULE_SHIFTS = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};
	
}

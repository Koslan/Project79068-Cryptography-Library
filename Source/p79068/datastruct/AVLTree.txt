package p79068.datastruct;


public class AVLTree{

 protected AVLTreeNode root;


 public AVLTree(){
  root=null;}


 public boolean insert(Comparable key){
  if(key==null)throw new NullPointerException();
  if(root==null){
   root=new AVLTreeNode(key);
   return true;}
  if(!insert(key,root))return false;
  root=balance(root);
  return true;}

 public Comparable search(Comparable key){
  if(key==null)throw new NullPointerException();
  AVLTreeNode node=root;
  while(node!=null){
   int comp=key.compareTo(node.value);
   if(comp<0)node=node.left;
   else if(comp>0)node=node.right;
   else return node.value;}
  return null;}

 public boolean remove(Comparable key){
  throw new RuntimeException("Not implemented");}


 private static boolean isBalanced(AVLTreeNode node){
  if(node==null)return true;
  return Math.abs(getHeight(node.left)-getHeight(node.right))<=1&&isBalanced(node.left)&&isBalanced(node.right);}

 private static int recomputeHeight(AVLTreeNode node){
  if(node==null)return 0;
  if(node.height!=1+Math.max(recomputeHeight(node.left),recomputeHeight(node.right)))throw new RuntimeException("Node height is wrong!");
  return node.height;}


 private static boolean insert(Comparable key,AVLTreeNode node){
  int comp=key.compareTo(node.value);
  if(comp<0){
   if(node.left!=null){
    if(!insert(key,node.left))return false;
    node.left=balance(node.left);}
   else node.left=new AVLTreeNode(key);}
  else if(comp>0){
   if(node.right!=null){
    if(!insert(key,node.right))return false;
    node.right=balance(node.right);}
   else node.right=new AVLTreeNode(key);}
  else return false;
  updateHeight(node);
  return true;}


 private static AVLTreeNode balance(AVLTreeNode node){ // Possibly performs a tree rotation, then returns the new root.
  int bal=getBalance(node);
  if(Math.abs(bal)>2)throw new RuntimeException("Tree is too unbalanced");
  if(bal==2)return rotateRight(node,true);
  else if(bal==-2)return rotateLeft(node,true);
  return node;}

 /*
 Left rotation:
    B             D
   / \           / \
  A   D   -->   B   E
     / \       / \
    C   E     A   C

 Notes:
 - While B and D must not be null, each of {A,C,E} have no such restriction.
 - Assume that B's balance is -2. If D's balance is +1, then a right rotation must be first performed on D.
 */
 private static AVLTreeNode rotateLeft(AVLTreeNode b,boolean recursive){
  AVLTreeNode d=b.right; // This cannot be null because B's right subtree has at least height 2.
  if(recursive&&getBalance(d)==1)d=rotateRight(d,false);
  b.right=d.left;
  d.left=b;
  updateHeight(b);
  updateHeight(d);
  return d;}

 /*
 Right rotation:
      D             B
     / \           / \
    B   E   -->   A   D
   / \               / \
  A   C             C   E

 Notes:
 - While B and D must not be null, each of {A,C,E} have no such restriction.
 - Assume that D's balance is +2. If B's balance is -1, then a left rotation must be first performed on B.
 */
 private static AVLTreeNode rotateRight(AVLTreeNode d,boolean recursive){
  AVLTreeNode b=d.left; // This cannot be null because D's left subtree has at least height 2.
  if(recursive&&getBalance(b)==-1)b=rotateLeft(b,false);
  d.left=b.right;
  b.right=d;
  updateHeight(d);
  updateHeight(b);
  return b;}


 private static void updateHeight(AVLTreeNode node){
  node.height=1+Math.max(getHeight(node.left),getHeight(node.right));}

 private static int getHeight(AVLTreeNode node){
  if(node==null)return 0;
  return node.height;}

 private static int getBalance(AVLTreeNode node){
  return getHeight(node.left)-getHeight(node.right);}}